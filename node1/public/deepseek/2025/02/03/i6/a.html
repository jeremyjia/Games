<!DOCTYPE html>
<html>
<head>
    <title>ç®€å•åœºæ™¯ç¼–è¾‘å™¨</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container {
            display: grid;
            grid-template-columns: 120px 1fr 200px;
            height: 100vh;
        }
        #toolbar { background: #f0f0f0; padding: 10px; }
        #canvas-container { position: relative; }
        #main-canvas { border: 1px solid #ccc; }
        #property-panel { background: #f8f8f8; padding: 10px; }
        .obj-type { 
            padding: 8px; 
            margin: 4px; 
            border: 1px solid #ccc;
            cursor: move;
            background: white;
        }
        .prop-item { margin: 10px 0; }
        #main-canvas {
            display: block;
            border: 2px solid #333;
            background: #87CEEB;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- å·¦ä¾§å·¥å…·æ  -->
        <div id="toolbar">
            <div class="obj-type" data-type="car">ğŸš— æ±½è½¦</div>
            <div class="obj-type" data-type="cloud">â˜ï¸ äº‘</div>
            <div class="obj-type" data-type="tree">ğŸŒ³ æ ‘</div>
        </div>

        <!-- ä¸»ç”»å¸ƒ -->
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
        </div>

        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div id="property-panel">
            <h3>å±æ€§</h3>
            <div id="props-content"></div>
            <button onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
            <pre id="output"></pre>
        </div>
    </div>

<script>
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
let isDragging = false;
let selectedObj = null;
let offsetX = 0, offsetY = 0;

// åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
canvas.width = 800;
canvas.height = 600;

// åœºæ™¯æ•°æ®
const scene = {
    background: '#87CEEB',
    objects: []
};

// å¯¹è±¡æ¨¡æ¿
const templates = {
    car: { width: 60, height: 30, color: '#FF4500' },
    cloud: { width: 80, height: 40, color: '#FFFFFF', density: 0.7 },
    tree: { width: 40, height: 80, color: '#228B22', trunkColor: '#8B4513' }
};

// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
document.querySelectorAll('.obj-type').forEach(item => {
    item.addEventListener('mousedown', startAddObject);
});

canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('mousemove', dragObject);
canvas.addEventListener('mouseup', endDrag);
canvas.addEventListener('click', selectObject);

// ä¸»æ¸²æŸ“å¾ªç¯
function render() {
    console.log(2);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶èƒŒæ™¯
    ctx.fillStyle = scene.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶å¯¹è±¡
    scene.objects.forEach(obj => {
        ctx.fillStyle = obj.color;
        switch(obj.type) {
            case 'car':
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                break;
            case 'cloud':
                drawCloud(obj);
                break;
            case 'tree':
                drawTree(obj);
                break;
        }
        
        // ç»˜åˆ¶é€‰ä¸­æ¡†
        if (obj === selectedObj) {
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(obj.x-2, obj.y-2, obj.width+4, obj.height+4);
        }
    });
}

// ä¿®å¤åæ ‡è®¡ç®—é—®é¢˜
function startAddObject(e) {
    const type = e.target.dataset.type;
    const rect = canvas.getBoundingClientRect();
    
    // è®¡ç®—æ­£ç¡®çš„ç”»å¸ƒåæ ‡
    const scaleX = canvas.width / canvas.offsetWidth;
    const scaleY = canvas.height / canvas.offsetHeight;
    
    const x = (e.clientX - rect.left) * scaleX - templates[type].width/2;
    const y = (e.clientY - rect.top) * scaleY - templates[type].height/2;
    
    const newObj = {
        type,
        x: Math.max(0, Math.min(x, canvas.width - templates[type].width)),  // è¾¹ç•Œé™åˆ¶
        y: Math.max(0, Math.min(y, canvas.height - templates[type].height)),
        ...templates[type]
    };
    
    scene.objects.push(newObj);
    console.log('Added:', newObj);  // è°ƒè¯•æ—¥å¿—
    render();
}
// æ·»åŠ åˆå§‹åŒ–æ£€æŸ¥
canvas.width = 800;
canvas.height = 600;
console.log('Canvas size:', canvas.width, canvas.height);  // ç¡®è®¤å°ºå¯¸
// æ·»åŠ å¸§ç‡ç›‘æ§
let lastRender = Date.now();
function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶èƒŒæ™¯
    ctx.fillStyle = scene.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶æ‰€æœ‰å¯¹è±¡
    scene.objects.forEach(obj => {
        ctx.save();
        drawObject(obj);
        ctx.restore();
    });
    
    // ç»˜åˆ¶é€‰ä¸­æ¡†
    if (selectedObj) {
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 2;
        ctx.strokeRect(
            selectedObj.x - 2,
            selectedObj.y - 2,
            selectedObj.width + 4,
            selectedObj.height + 4
        );
    }
    
    // æ˜¾ç¤ºå¸§ç‡
    const now = Date.now();
    const fps = 1000 / (now - lastRender);
    lastRender = now;
    ctx.fillStyle = '#000';
    ctx.fillText(`FPS: ${fps.toFixed(1)}`, 10, 20);
}

// æ·»åŠ äº‹ä»¶ç›‘å¬å®¹é”™
window.addEventListener('load', () => {
    document.querySelectorAll('.obj-type').forEach(item => {
        item.addEventListener('mousedown', startAddObject);
    });
});
// é€‰æ‹©å¯¹è±¡
function selectObject(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    selectedObj = scene.objects.find(obj => 
        x > obj.x && x < obj.x + obj.width &&
        y > obj.y && y < obj.y + obj.height
    );
    
    updatePropertyPanel();
    render();
}

// æ›´æ–°å±æ€§é¢æ¿
function updatePropertyPanel() {
    const panel = document.getElementById('props-content');
    if (!selectedObj) {
        panel.innerHTML = 'è¯·é€‰æ‹©å¯¹è±¡';
        return;
    }
    
    let html = `
        <div class="prop-item">
            <label>X: <input type="number" value="${selectedObj.x}" 
                   onchange="updateProp('x', this.value)"></label>
        </div>
        <div class="prop-item">
            <label>Y: <input type="number" value="${selectedObj.y}" 
                   onchange="updateProp('y', this.value)"></label>
        </div>
        <div class="prop-item">
            <label>é¢œè‰²: <input type="color" value="${selectedObj.color}" 
                   onchange="updateProp('color', this.value)"></label>
        </div>
    `;
    
    if (selectedObj.type === 'cloud') {
        html += `
            <div class="prop-item">
                <label>å¯†åº¦: 
                <input type="range" min="0" max="1" step="0.1" 
                       value="${selectedObj.density}" 
                       onchange="updateProp('density', this.value)">
                </label>
            </div>
        `;
    }
    
    panel.innerHTML = html;
}

// æ›´æ–°å¯¹è±¡å±æ€§
function updateProp(prop, value) {
    if (!selectedObj) return;
    selectedObj[prop] = (prop === 'x' || prop === 'y') ? 
        parseInt(value) : value;
    render();
}

// æ‹–åŠ¨åŠŸèƒ½
function startDrag(e) {
    console.log(3)
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    selectedObj = scene.objects.find(obj => 
        x > obj.x && x < obj.x + obj.width &&
        y > obj.y && y < obj.y + obj.height
    );
    
    if (selectedObj) {
        isDragging = true;
        offsetX = x - selectedObj.x;
        offsetY = y - selectedObj.y;
    }
}

function dragObject(e) {
    if (!isDragging || !selectedObj) return;
    
    const rect = canvas.getBoundingClientRect();
    selectedObj.x = e.clientX - rect.left - offsetX;
    selectedObj.y = e.clientY - rect.top - offsetY;
    
    render();
}

function endDrag() {
    isDragging = false;
    updatePropertyPanel();
}

// ç»˜åˆ¶äº‘æœµ 
function drawCloud(obj) {
    ctx.fillStyle = obj.color;
    
    // åˆ›å»ºç»„åˆè·¯å¾„
    ctx.beginPath();
    
    // ä¸»äº‘ä½“ï¼ˆä¸‰ä¸ªé‡å åœ†ï¼‰
    ctx.arc(obj.x + 25, obj.y + 20, 20, 0, Math.PI * 2);  // å·¦åœ†
    ctx.arc(obj.x + 50, obj.y + 15, 25, 0, Math.PI * 2);  // ä¸­å¿ƒåœ†
    ctx.arc(obj.x + 75, obj.y + 20, 20, 0, Math.PI * 2);  // å³åœ†
    
    // å¡«å……è·¯å¾„
    ctx.fill();
}

// ç»˜åˆ¶æ ‘æœ¨ï¼ˆè°ƒæ•´åæ ‡è®¡ç®—ï¼‰
function drawTree(obj) {
    // æ ‘å¹²ï¼ˆè°ƒæ•´ä½ç½®åˆ°ä¸­å¿ƒï¼‰
    ctx.fillStyle = obj.trunkColor;
    ctx.fillRect(
        obj.x + obj.width/2 - 5,  // å±…ä¸­
        obj.y + obj.height - 30,  // åº•éƒ¨ç•™å‡ºç©ºé—´
        10, 
        30
    );
    
    // æ ‘å† ï¼ˆè°ƒæ•´ä½ç½®ï¼‰
    ctx.fillStyle = obj.color;
    ctx.beginPath();
    ctx.arc(
        obj.x + obj.width/2,     // ä¸­å¿ƒX
        obj.y + obj.height - 50, // ä¸­å¿ƒY
        25,                      // åŠå¾„
        0, 
        Math.PI * 2
    );
    ctx.fill();
}
// å¯¼å‡ºæ•°æ®
function exportData() {
    const output = {
        background: scene.background,
        objects: scene.objects.map(obj => ({
            type: obj.type,
            x: obj.x,
            y: obj.y,
            color: obj.color,
            ...(obj.density && { density: obj.density })
        }))
    };
    
    document.getElementById('output').textContent = 
        JSON.stringify(output, null, 2);
}

// åˆå§‹æ¸²æŸ“
render();
console.log(1);
</script>
</body>
</html>