<!DOCTYPE html>
<html>
<head>
    <title>专业视频数据编辑器</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial;
        }

        #mainCanvas {
            position: fixed;
            left: 20vw;
            top: 10vh;
            width: 60vw;
            height: 60vh;
            border: 2px solid #333;
        }

        .toolbar {
            position: fixed;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            min-width: 120px;
            touch-action: none;
        }

        .toolbar-header {
            padding: 8px;
            background: rgba(0,0,0,0.1);
            cursor: grab;
            border-radius: 8px 8px 0 0;
            user-select: none;
        }

        .toolbar-content {
            padding: 10px;
        }

        .timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: #333;
            padding: 10px;
            overflow-x: auto;
        }

        .timeline-frame {
            display: inline-block;
            width: 80px;
            height: 60px;
            margin: 5px;
            border: 2px solid #666;
            cursor: pointer;
            position: relative;
        }

        .timeline-frame.active {
            border-color: #ffd700;
        }

        .property-panel {
            position: fixed;
            right: 20px;
            top: 200px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            min-width: 200px;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <div class="timeline"></div>
    <div class="property-panel" style="display: none;"></div>

    <script>
        const BACKGROUNDS = ['海边', '马路边', '树林', '操场'];
        const OBJECT_TYPES = ['汽车', '树木', '小狗'];

        class HighDPICanvas {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.pixelRatio = window.devicePixelRatio || 1;
                this.resize();
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * this.pixelRatio;
                this.canvas.height = rect.height * this.pixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.ctx.scale(this.pixelRatio, this.pixelRatio);
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawBackground(type) {
                // 背景绘制逻辑（同原始版本）
            }

            drawObject(obj) {
                // 对象绘制逻辑（同原始版本）
            }
        }

        class FrameManager {
            constructor() {
                this.frames = [];
                this.currentIndex = 0;
                this.history = [];
            }

            get currentFrame() {
                return this.frames[this.currentIndex];
            }

            addFrame() {
                const newFrame = {
                    id: Date.now(),
                    background: BACKGROUNDS[Math.floor(Math.random() * BACKGROUNDS.length)],
                    objects: []
                };
                this.frames.push(newFrame);
                this.saveState();
                return newFrame;
            }

            deleteFrame(index) {
                if (this.frames.length <= 1) return;
                this.frames.splice(index, 1);
                this.currentIndex = Math.min(index, this.frames.length - 1);
                this.saveState();
            }

            saveState() {
                this.history.push(JSON.stringify(this.frames));
                if (this.history.length > 50) this.history.shift();
            }

            undo() {
                if (this.history.length > 1) {
                    this.history.pop();
                    this.frames = JSON.parse(this.history[this.history.length - 1]);
                }
            }
        }

        class ObjectInteractor {
            constructor(canvas, frameManager) {
                this.canvas = canvas;
                this.frameManager = frameManager;
                this.selectedObject = null;
                this.initEvents();
            }

            initEvents() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            // 事件处理逻辑（同改进版本）
        }

        class AnimationSystem {
            constructor(frameManager, renderCallback) {
                this.frameManager = frameManager;
                this.renderCallback = renderCallback;
                this.isPlaying = false;
                this.rafId = null;
                this.fps = 24;
            }

            play() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                const interval = 1000 / this.fps;
                let lastTime = 0;

                const animate = (timestamp) => {
                    if (!this.isPlaying) return;
                    
                    if (timestamp - lastTime >= interval) {
                        this.frameManager.currentIndex = 
                            (this.frameManager.currentIndex + 1) % this.frameManager.frames.length;
                        this.renderCallback();
                        lastTime = timestamp;
                    }
                    this.rafId = requestAnimationFrame(animate);
                };

                this.rafId = requestAnimationFrame(animate);
            }

            stop() {
                this.isPlaying = false;
                cancelAnimationFrame(this.rafId);
            }
        }

        class Timeline {
            constructor(container, frameManager) {
                this.container = container;
                this.frameManager = frameManager;
                this.init();
            }

            init() {
                this.frameManager.frames.forEach((frame, index) => {
                    this.createThumbnail(frame, index);
                });
            }

            createThumbnail(frame, index) {
                const element = document.createElement('div');
                element.className = 'timeline-frame';
                element.innerHTML = `<div class="thumbnail" data-index="${index}"></div>`;
                element.addEventListener('click', () => {
                    this.frameManager.currentIndex = index;
                    this.updateActiveState();
                });
                this.container.appendChild(element);
                this.updateThumbnail(element, frame);
            }

            updateActiveState() {
                this.container.querySelectorAll('.timeline-frame').forEach((el, i) => {
                    el.classList.toggle('active', i === this.frameManager.currentIndex);
                });
            }

            updateThumbnail(element, frame) {
                // 缩略图生成逻辑
            }
        }

        class PropertyEditor {
            constructor(panel) {
                this.panel = panel;
                this.currentObject = null;
            }

            show(object) {
                this.currentObject = object;
                this.panel.style.display = 'block';
                this.panel.innerHTML = `
                    <h3>属性编辑</h3>
                    <label>X: <input type="number" value="${object.x}" class="prop-x"></label>
                    <label>Y: <input type="number" value="${object.y}" class="prop-y"></label>
                    <label>缩放: 
                        <input type="range" min="0.5" max="2" step="0.1" 
                               value="${object.scale}" class="prop-scale">
                    </label>
                `;

                this.panel.querySelectorAll('input').forEach(input => {
                    input.addEventListener('change', () => this.updateObject(input));
                });
            }

            updateObject(input) {
                const prop = input.classList.contains('prop-x') ? 'x' :
                            input.classList.contains('prop-y') ? 'y' : 'scale';
                this.currentObject[prop] = parseFloat(input.value);
            }
        }

        class VideoEditor {
            constructor() {
                this.canvas = new HighDPICanvas();
                this.frameManager = new FrameManager();
                this.objectInteractor = new ObjectInteractor(this.canvas.canvas, this.frameManager);
                this.animationSystem = new AnimationSystem(this.frameManager, () => this.render());
                this.timeline = new Timeline(document.querySelector('.timeline'), this.frameManager);
                this.propertyEditor = new PropertyEditor(document.querySelector('.property-panel'));
                this.initToolbars();
                this.init();
            }

            init() {
                window.addEventListener('resize', () => this.canvas.resize());
                this.frameManager.addFrame();
                this.render();
            }

            render() {
                this.canvas.clear();
                const frame = this.frameManager.currentFrame;
                if (!frame) return;

                this.canvas.drawBackground(frame.background);
                frame.objects.forEach(obj => this.canvas.drawObject(obj));
            }

            initToolbars() {
                // 工具栏初始化逻辑（同原始版本）
                // 添加背景、对象、播放控制等工具栏
            }
        }

        // 初始化编辑器
        new VideoEditor();
    </script>
</body>
</html>