<!-- public/index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Video Editor</title>
  <link href="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.6/dist/jsoneditor.min.css" rel="stylesheet">
  <style>
    .window {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      min-width: 300px;
      min-height: 200px;
      overflow: hidden; 
      resize: none; /* 禁用CSS默认resize */
    }
    .window-header {
      padding: 8px 32px 8px 12px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
      cursor: move;
      position: relative;
      user-select: none;
    }
    .window-close {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      font-size: 18px;
      color: #666;
    }

    .window-close:hover {
      color: #333;
    }
    .window-content {
      height: calc(100% - 35px);
    }

    #container {
      display: grid;
      grid-template-columns: 1fr;
      padding: 20px;
    }

    canvas {
      border: 1px solid #ccc;
      background: white;
      margin-top: 20px;
    }

    .controls {
      margin: 10px 0;
    }

    button {
      padding: 8px 16px;
      margin-right: 10px;
    } 
    #videoWindow {
      width: 800px;
      height: 600px;
    }
    #editor {
    width: 100%;
    height: 100%;
  }
  .jsoneditor-outer {
    height: calc(100% - 30px) !important;
  }
    #videoPreview {
      background: black;
    }
    .window-resize-handle {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 12px;
        height: 12px;
        cursor: nwse-resize;
        background: transparent;
        z-index: 1;
    }
    button {
      padding: 8px 16px;
      margin-right: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #0056b3;
    }

    button.active {
      background-color: #4CAF50;
    }

    button.active:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div class="controls">
    <button onclick="saveData()">Save</button>
    <button onclick="playAnimation()">Play</button>
    <button onclick="exportVideo()">Export Video</button> <!-- 新增按钮 -->
    <button id="toggleEditorBtn" onclick="toggleEditorWindow()">Toggle Editor</button>
  </div>
  
  <div class="window" id="editorWindow" style="left: 20px; top: 60px">
    <div class="window-header">
      JSON Editor 
      <span class="window-close">×</span>
    </div>
    <div class="window-content" id="editor"></div>
  </div>


  <div id="container">
    <canvas id="canvas"></canvas>
  </div>
<!-- 在index.html的body末尾添加视频播放窗口 -->
<div class="window preview-window" id="videoWindow" style="left: 650px; top: 60px; display: none; width: 800px; height: 600px;">
  <div class="window-header">视频预览 <span class="window-close">×</span></div>
  <div class="window-content" style="position: relative; height: calc(100% - 35px);">
    <video id="videoPreview" controls style="width: 100%; height: 90%;"></video>
    <button onclick="downloadVideo()" 
            style="position: absolute; bottom: 10px; right: 10px; padding: 8px 16px;"
            title="下载视频">
      下载
    </button>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/jsoneditor@9.5.6/dist/jsoneditor.min.js"></script>
  <script>
    function toggleEditorWindow() {
      const editorWindow = document.getElementById('editorWindow');
      const btn = document.getElementById('toggleEditorBtn');
      const currentDisplay = window.getComputedStyle(editorWindow).display;
      
      if (currentDisplay === 'none') {
        editorWindow.style.display = 'block';
        windowManager.bringToFront(editorWindow);
        btn.classList.add('active');
      } else {
        editorWindow.style.display = 'none';
        btn.classList.remove('active');
      }
    }

    // 统一窗口管理逻辑
class WindowManager {
  constructor() {
        this.windows = new Set();
        this.activeWindow = null;
        this.isResizing = false;
        this.initialWidth = 0;
        this.initialHeight = 0;
        this.startX = 0;
        this.startY = 0;
        this.init();
  }

  init() {
        document.addEventListener('mousedown', this.handleMouseDown.bind(this));
        document.addEventListener('mousemove', this.handleMouseMove.bind(this));
        document.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        document.querySelectorAll('.window').forEach(window => this.registerWindow(window));
    }

    registerWindow(windowElement) {
        if (!this.windows.has(windowElement)) {
            this.windows.add(windowElement);
            this.addCloseHandler(windowElement);
            this.addResizeHandle(windowElement); // 添加调整手柄
        }
    }

  addCloseHandler(windowElement) {
    const closeBtn = windowElement.querySelector('.window-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        e.stopPropagation(); // 防止触发拖动事件
        windowElement.style.display = 'none';
      });
    }
  }

  addResizeHandle(windowElement) {
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'window-resize-handle';
        windowElement.appendChild(resizeHandle);
    }
  
    handleMouseDown(e) {
        const resizeHandle = e.target.closest('.window-resize-handle');
        if (resizeHandle) {
            const windowElement = resizeHandle.parentElement;
            this.isResizing = true;
            this.activeWindow = windowElement;
            this.initialWidth = windowElement.offsetWidth;
            this.initialHeight = windowElement.offsetHeight;
            this.startX = e.clientX;
            this.startY = e.clientY;
            this.bringToFront(windowElement);
            e.preventDefault();
            return;
        }

        const header = e.target.closest('.window-header');
        if (!header) return;

        const windowElement = header.parentElement;
        this.activeWindow = windowElement;
        const rect = windowElement.getBoundingClientRect();
        this.offset = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        this.bringToFront(windowElement);
    }

    handleMouseMove(e) {
        if (this.isResizing) {
            const deltaX = e.clientX - this.startX;
            const deltaY = e.clientY - this.startY;
            const minSize = 100; // 最小窗口尺寸
            
            const newWidth = Math.max(minSize, this.initialWidth + deltaX);
            const newHeight = Math.max(minSize, this.initialHeight + deltaY);
            
            this.activeWindow.style.width = `${newWidth}px`;
            this.activeWindow.style.height = `${newHeight}px`;
            return;
        }

        if (!this.activeWindow) return;

        const x = e.clientX - this.offset.x;
        const y = e.clientY - this.offset.y;
        this.activeWindow.style.left = `${x}px`;
        this.activeWindow.style.top = `${y}px`;
    }
  
    
    handleMouseUp() {
        this.activeWindow = null;
        this.isResizing = false;
    }
  bringToFront(windowElement) {
    const currentMaxZ = Math.max(...[...this.windows].map(w => 
      parseInt(w.style.zIndex) || 1000));
    
    windowElement.style.zIndex = currentMaxZ + 1;
  }
}

// 初始化窗口管理
let windowManager;

document.addEventListener('DOMContentLoaded', () => {
  windowManager = new WindowManager();
  
  // 注册动态创建的窗口（如果有）
  const videoWindow = document.getElementById('videoWindow');
  if (videoWindow) windowManager.registerWindow(videoWindow);

  
  const editorWindow = document.getElementById('editorWindow');
  const toggleBtn = document.getElementById('toggleEditorBtn');
  if (window.getComputedStyle(editorWindow).display !== 'none') {
    toggleBtn.classList.add('active');
  }
});
    let currentVideoUrl = null;
    function showVideoWindow() {
  const videoWindow = document.getElementById('videoWindow');
  videoWindow.style.display = 'block';
  // 将视频窗口置于最前
  document.querySelectorAll('.window').forEach(w => w.style.zIndex = 1000);
  videoWindow.style.zIndex = 1001;
}

function cleanupVideo() {
  if (currentVideoUrl) {
    URL.revokeObjectURL(currentVideoUrl);
    currentVideoUrl = null;
  }
}
function downloadVideo() {
  if (!currentVideoUrl) return;
  
  const a = document.createElement('a');
  a.href = currentVideoUrl;
  a.download = `video-${Date.now()}.mp4`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


    // 新增窗口拖动功能
    let isDragging = false;
    let currentX = 0;
    let currentY = 0;
    let initialX = 0;
    let initialY = 0;
    let xOffset = 0;
    let yOffset = 0;

    const windowElement = document.getElementById('editorWindow');
    const header = document.querySelector('.window-header');

    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;

      if (e.target === header) {
        isDragging = true;
      }
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;

        xOffset = currentX;
        yOffset = currentY;

        setTranslate(currentX, currentY, windowElement);
      }
    }

    function setTranslate(xPos, yPos, el) {
      el.style.left = xPos + 'px';
      el.style.top = yPos + 'px';
    }

    function dragEnd(e) {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
    }

    // 以下保持原有逻辑不变...
    let editor = null;
    let animationFrame = null;
    let currentSceneIndex = 0;
    let startTime = null;
    
    // 初始化编辑器
    const container = document.getElementById('editor');
    const options = { mode: 'code' };
    editor = new JSONEditor(container, options);
    function setupEditorResize() {
    const editorWindow = document.getElementById('editorWindow');
    const observer = new ResizeObserver(() => {
      if (editor && editor.aceEditor) {
        const container = editor.container;
        const modes = container.querySelector('.jsoneditor-modes');
        const content = container.querySelector('.jsoneditor-outer');
        
        if (modes && content) {
          content.style.height = `calc(100% - ${modes.offsetHeight}px)`;
        }
        setTimeout(() => editor.aceEditor.resize(), 10);
      }
    });
    observer.observe(editorWindow);
  }
  fetch('/data')
    .then(res => res.json())
    .then(data => {
      editor.set(data);
      setupEditorResize(); // 初始化尺寸监听
    })
    .catch(() => {
      editor.set(initialData);
      setupEditorResize();
    });

    // 保存数据
    function saveData() {
      fetch('/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(editor.get())
      });
    }

    // 动画渲染和播放逻辑保持原样...
    // ...（保持原有的renderScene和playAnimation函数不变）
    
    
    // 动画渲染
    function renderScene(scene) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // 设置画布尺寸
      canvas.width = 1024;
      canvas.height = 768;

      // 绘制背景
      ctx.fillStyle = scene.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 绘制元素
      scene.elements.forEach(element => {
        ctx.fillStyle = element.color;
        ctx.strokeStyle = element.color;
        
        switch(element.type) {
          case 'circle':
            ctx.beginPath();
            ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(element.x1, element.y1);
            ctx.lineTo(element.x2, element.y2);
            ctx.lineTo(element.x3, element.y3);
            ctx.closePath();
            ctx.fill();
            break;
          case 'line':
            ctx.beginPath();
            ctx.moveTo(element.x1, element.y1);
            ctx.lineTo(element.x2, element.y2);
            ctx.stroke();
            break;
        }
      });
    }

    // 播放动画
    function playAnimation(timestamp) {
      const data = editor.get();
      const scenes = data.scenes;
      const fps = data.fps || 1;

      if (!startTime) startTime = timestamp;
      
      const elapsed = timestamp - startTime;
      const frameDuration = 1000 / fps;
      const totalDuration = scenes.reduce((acc, scene) => 
        acc + (scene.duration * frameDuration), 0);
      
      const currentTime = elapsed % totalDuration;
      
      let accumulated = 0;
      let currentScene = scenes[0];
      
      for (const scene of scenes) {
        accumulated += scene.duration * frameDuration;
        if (currentTime < accumulated) {
          currentScene = scene;
          break;
        }
      }

      renderScene(currentScene);
      animationFrame = requestAnimationFrame(playAnimation);
    }

    // 停止动画
    function stopAnimation() {
      cancelAnimationFrame(animationFrame);
      startTime = null;
    }
    
    function exportVideo() {
  const data = editor.get();
  const btn = event.target;
  const originalText = btn.textContent;

  // 清理之前的视频
  cleanupVideo();

  btn.textContent = '生成中...';
  btn.disabled = true;

  fetch('/export', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  .then(response => {
    if (!response.ok) throw new Error('生成失败: ' + response.statusText);
    return response.blob();
  })
  .then(blob => {
    currentVideoUrl = URL.createObjectURL(blob);
    const videoPlayer = document.getElementById('videoPreview');
    videoPlayer.src = currentVideoUrl;
    showVideoWindow();
    videoPlayer.play();
  })
  .catch(error => {
    console.error('导出错误:', error);
    alert(error.message);
  })
  .finally(() => {
    btn.textContent = originalText;
    btn.disabled = false;
  });
}
function initWindowDrag() {
  function setupWindowDrag(windowElement) {
    let isDragging = false;
    let currentX = 0;
    let currentY = 0;
    let initialX = 0;
    let initialY = 0;

    const header = windowElement.querySelector('.window-header');

    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      initialX = e.clientX - windowElement.offsetLeft;
      initialY = e.clientY - windowElement.offsetTop;
      isDragging = true;
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;

        windowElement.style.left = `${currentX}px`;
        windowElement.style.top = `${currentY}px`;
      }
    }

    function dragEnd() {
      isDragging = false;
    }
  }

  // 为所有窗口初始化拖动
  document.querySelectorAll('.window').forEach(setupWindowDrag);
}

window.addEventListener('load', () => {
  initWindowDrag();
  
  // 关闭按钮处理（可选）
  document.querySelectorAll('.window').forEach(window => {
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      position: absolute;
      right: 8px;
      top: 5px;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
    `;
    closeBtn.onclick = () => window.style.display = 'none';
    window.querySelector('.window-header').appendChild(closeBtn);
  });
});
  </script>
</body>
</html>