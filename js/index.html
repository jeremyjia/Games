<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>全屏画布</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        /* 主画布层级设置 */
        #myCanvas {
            background: #f0f0f0;
            touch-action: none;
            position: relative;  /* 关键定位 */
            z-index: 1;          /* 基础层级 */
        }

        /* 工具按钮容器 */
        #tools {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
            z-index: 1000;       /* 最高层级 */
        }

        /* AOI覆盖层样式 */
        .aoi-overlay {
            pointer-events: none !important;  /* 强制事件穿透 */
            position: fixed;
            left: 0;
            top: 0;
            z-index: 2;          /* 介于画布和工具之间 */
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <div id="tools">
        <button onclick="changeColor('#ff0000')">红</button>
        <button onclick="changeColor('#00ff00')">绿</button>
        <button onclick="changeColor('#0000ff')">蓝</button>
        <button onclick="clearCanvas()">清空</button>  
        <button onclick="toggleAOI()">toggleAOI</button>  
        <input type="range" id="brushSize" min="1" max="50" value="5">
    </div>

    <script>
        // AOI控制模块
        class AOIController {
            constructor(mainCtx) {
                this.ctx = mainCtx;
                this.isVisible = false;
                
                // 创建覆盖层
                this.overlay = document.createElement('canvas');
                this.overlay.className = 'aoi-overlay';
                document.body.appendChild(this.overlay);  // 确保在画布之后插入
                this.overlayCtx = this.overlay.getContext('2d');
                
                // 初始同步尺寸
                this.syncSize();
                window.addEventListener('resize', () => this.syncSize());
            }

            syncSize() {
                // 精确同步画布尺寸
                this.overlay.width = this.ctx.canvas.width;
                this.overlay.height = this.ctx.canvas.height;
                this.overlay.style.width = this.ctx.canvas.width + 'px';
                this.overlay.style.height = this.ctx.canvas.height + 'px';
                if(this.isVisible) this.draw();
            }

            draw() {
                this.overlayCtx.clearRect(0, 0, this.overlay.width, this.overlay.height);
                this.overlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                this.overlayCtx.lineWidth = 3;
                this.overlayCtx.setLineDash([8, 4]);
                this.overlayCtx.strokeRect(50, 100, 200, 200);
            }

            toggle() {
                this.isVisible = !this.isVisible;
                this.isVisible ? this.draw() : this.overlayCtx.clearRect(0, 0, this.overlay.width, this.overlay.height);
            }
        }

        // 主程序逻辑
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let aoiController = null;
        
        // 状态变量
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';

        // 画布初始化
        function initCanvas() {
            const resize = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if(aoiController) aoiController.syncSize();
            };
            window.addEventListener('resize', resize);
            resize();
        }

        // 事件坐标计算
        function getPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches?.[0]?.clientX || e.clientX;
            const clientY = e.touches?.[0]?.clientY || e.clientY;
            return {
                x: clientX - rect.left * (canvas.width / rect.width),
                y: clientY - rect.top * (canvas.height / rect.height)
            };
        }

        // 绘图逻辑
        const startDrawing = e => {
            isDrawing = true;
            const pos = getPosition(e);
            [lastX, lastY] = [pos.x, pos.y];
        };

        const draw = e => {
            if (!isDrawing) return;
            const pos = getPosition(e);
            
            ctx.beginPath();
            ctx.lineWidth = document.getElementById('brushSize').value;
            ctx.lineCap = 'round';
            ctx.strokeStyle = currentColor;
            
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            [lastX, lastY] = [pos.x, pos.y];
        };

        // 事件绑定
        function bindEvents() {
            const endDrawing = () => isDrawing = false;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseout', endDrawing);

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                startDrawing(e);
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                draw(e);
            });
            canvas.addEventListener('touchend', endDrawing);
        }

        // 控制功能
        function changeColor(color) {
            currentColor = color;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function toggleAOI() {
            if (!aoiController) aoiController = new AOIController(ctx);
            aoiController.toggle();
        }

        // 初始化
        initCanvas();
        bindEvents();
    </script>
</body>
</html>